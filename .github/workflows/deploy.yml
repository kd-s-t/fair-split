name: CI/CD Build and Deploy to EC2

on:
  push:
    branches: [development]
  pull_request:
    branches: [development]
    types: [closed]
  workflow_dispatch: # Manual trigger

jobs:
  build:
    runs-on: ubuntu-latest
    steps:
      - name: Checkout code
        uses: actions/checkout@v4

      - name: Read SSM public envs for build
        id: read-ssm
        run: |
          AWS_REGION=us-east-1
          SSM_PATH="/splitsafe/development"
          mapfile -t lines < <(aws ssm get-parameters-by-path --path "$SSM_PATH" --with-decryption --recursive --region "$AWS_REGION" --query 'Parameters[*].[Name,Value]' --output text)
          for l in "${lines[@]}"; do
            k=$(echo "$l" | awk '{print $1}')
            v=$(echo "$l" | awk '{print $2}')
            key=${k##*/}
            echo "$key=$v" >> $GITHUB_OUTPUT
          done

      - name: Setup Node.js
        uses: actions/setup-node@v4
        with:
          node-version: '20.17.0'
          cache: 'npm'
          cache-dependency-path: 'package-lock.json'

      - name: Install dependencies
        run: npm ci

      - name: Build application
        run: npm run build

  build-and-push-ecr:
    needs: build
    runs-on: ubuntu-latest
    if: github.ref == 'refs/heads/development' || (github.event_name == 'pull_request' && github.event.pull_request.merged == true)
    
    steps:
      - name: Checkout code
        uses: actions/checkout@v4

      - name: Configure AWS credentials
        uses: aws-actions/configure-aws-credentials@v4
        with:
          aws-access-key-id: ${{ secrets.AWS_ACCESS_KEY_ID }}
          aws-secret-access-key: ${{ secrets.AWS_SECRET_ACCESS_KEY }}
          aws-region: us-east-1

      - name: Login to Amazon ECR
        id: login-ecr
        uses: aws-actions/amazon-ecr-login@v2

      - name: Read SSM public envs for build
        id: read-ssm
        run: |
          AWS_REGION=us-east-1
          SSM_PATH="/splitsafe/development"
          mapfile -t lines < <(aws ssm get-parameters-by-path --path "$SSM_PATH" --with-decryption --recursive --region "$AWS_REGION" --query 'Parameters[*].[Name,Value]' --output text)
          for l in "${lines[@]}"; do
            k=$(echo "$l" | awk '{print $1}')
            v=$(echo "$l" | awk '{print $2}')
            key=${k##*/}
            echo "$key=$v" >> $GITHUB_OUTPUT
          done

      - name: Create ECR repository if it doesn't exist
        run: |
          REPO_NAME="splitsafe-development"
          echo "üîç Checking if ECR repository $REPO_NAME exists..."
          
          if ! aws ecr describe-repositories --repository-names $REPO_NAME --region us-east-1 2>/dev/null; then
            echo "üì¶ Creating ECR repository $REPO_NAME..."
            aws ecr create-repository \
              --repository-name $REPO_NAME \
              --region us-east-1 \
              --image-scanning-configuration scanOnPush=true \
              --image-tag-mutability MUTABLE
            echo "‚úÖ ECR repository $REPO_NAME created successfully"
          else
            echo "‚úÖ ECR repository $REPO_NAME already exists"
          fi

      - name: Build and push Docker image
        env:
          ECR_REGISTRY: ${{ steps.login-ecr.outputs.registry }}
          ECR_REPOSITORY: splitsafe-development
          IMAGE_TAG: ${{ github.sha }}
          # Pull public envs from SSM so Next.js client bundle gets them at build time
          NEXT_PUBLIC_DFX_HOST: ${{ steps.read-ssm.outputs.NEXT_PUBLIC_DFX_HOST }}
          NEXT_PUBLIC_CANISTER_ID_SPLIT_DAPP: ${{ steps.read-ssm.outputs.NEXT_PUBLIC_CANISTER_ID_SPLIT_DAPP }}
          NEXT_PUBLIC_DOMAIN: ${{ steps.read-ssm.outputs.NEXT_PUBLIC_DOMAIN }}
          NEXT_PUBLIC_DEVELOPMENT_DOMAIN: ${{ steps.read-ssm.outputs.NEXT_PUBLIC_DEVELOPMENT_DOMAIN }}
          NEXT_PUBLIC_BLOCKSTREAM_URL: ${{ steps.read-ssm.outputs.NEXT_PUBLIC_BLOCKSTREAM_URL }}
          NEXT_PUBLIC_MEMPOOL_URL: ${{ steps.read-ssm.outputs.NEXT_PUBLIC_MEMPOOL_URL }}
          NEXT_PUBLIC_ICP_DASHBOARD_URL: ${{ steps.read-ssm.outputs.NEXT_PUBLIC_ICP_DASHBOARD_URL }}
          NEXT_PUBLIC_ICSCAN_URL: ${{ steps.read-ssm.outputs.NEXT_PUBLIC_ICSCAN_URL }}
        run: |
          echo "üê≥ Building Production Docker image..."
          docker buildx create --use || true
          docker buildx build --platform linux/amd64 \
            -t $ECR_REGISTRY/$ECR_REPOSITORY:$IMAGE_TAG \
            -f docker/production/Dockerfile \
            --build-arg NEXT_PUBLIC_DFX_HOST="$NEXT_PUBLIC_DFX_HOST" \
            --build-arg NEXT_PUBLIC_CANISTER_ID_SPLIT_DAPP="$NEXT_PUBLIC_CANISTER_ID_SPLIT_DAPP" \
            --build-arg NEXT_PUBLIC_DOMAIN="$NEXT_PUBLIC_DOMAIN" \
            --build-arg NEXT_PUBLIC_DEVELOPMENT_DOMAIN="$NEXT_PUBLIC_DEVELOPMENT_DOMAIN" \
            --build-arg NEXT_PUBLIC_BLOCKSTREAM_URL="$NEXT_PUBLIC_BLOCKSTREAM_URL" \
            --build-arg NEXT_PUBLIC_MEMPOOL_URL="$NEXT_PUBLIC_MEMPOOL_URL" \
            --build-arg NEXT_PUBLIC_ICP_DASHBOARD_URL="$NEXT_PUBLIC_ICP_DASHBOARD_URL" \
            --build-arg NEXT_PUBLIC_ICSCAN_URL="$NEXT_PUBLIC_ICSCAN_URL" \
            --push .
          
          # Verify the image was pushed successfully
          echo "üîç Verifying image was pushed successfully..."
          if aws ecr describe-images --repository-name $ECR_REPOSITORY --image-ids imageTag=$IMAGE_TAG --region us-east-1 2>/dev/null; then
            echo "‚úÖ Image pushed and verified: $ECR_REGISTRY/$ECR_REPOSITORY:$IMAGE_TAG"
          else
            echo "‚ùå Failed to verify image in ECR: $ECR_REGISTRY/$ECR_REPOSITORY:$IMAGE_TAG"
            echo "üîç Available images in repository:"
            aws ecr describe-images --repository-name $ECR_REPOSITORY --region us-east-1 --query 'imageDetails[*].imageTags' --output table || echo "No images found"
            exit 1
          fi

  deploy:
    needs: [build, build-and-push-ecr]
    runs-on: ubuntu-latest
    if: github.ref == 'refs/heads/development' || (github.event_name == 'pull_request' && github.event.pull_request.merged == true)
    
    steps:
      - name: Checkout code
        uses: actions/checkout@v4

      - name: Setup SSH agent
        uses: webfactory/ssh-agent@v0.8.0
        with:
          ssh-private-key: ${{ secrets.EC2_SSH_KEY }}

      - name: Install network tools
        run: |
          sudo apt-get update
          sudo apt-get install -y netcat-openbsd

      - name: Add EC2 to known hosts
        run: |
          echo "üîç Testing connectivity to EC2 host..."
          echo "Host: ${{ secrets.EC2_HOST }}"
          echo "Port: ${{ secrets.EC2_PORT }}"
          
          # Test SSH port connectivity (skip ping as many EC2 instances block ICMP)
          if ! nc -z -w5 ${{ secrets.EC2_HOST }} ${{ secrets.EC2_PORT }}; then
            echo "‚ùå Cannot connect to ${{ secrets.EC2_HOST }}:${{ secrets.EC2_PORT }}"
            echo "üîç This could be due to:"
            echo "   - Incorrect EC2_HOST secret"
            echo "   - Incorrect EC2_PORT secret"
            echo "   - EC2 instance is down"
            echo "   - Security group blocking SSH"
            exit 1
          fi
          
          echo "‚úÖ SSH port is accessible, attempting SSH key scan..."
          
          # Try ssh-keyscan with different options
          if ! ssh-keyscan -H -p ${{ secrets.EC2_PORT }} ${{ secrets.EC2_HOST }} >> ~/.ssh/known_hosts 2>/dev/null; then
            echo "‚ö†Ô∏è ssh-keyscan failed, trying without port specification..."
            if ! ssh-keyscan -H ${{ secrets.EC2_HOST }} >> ~/.ssh/known_hosts 2>/dev/null; then
              echo "‚ùå Failed to add host to known_hosts"
              echo "üîç Attempting manual SSH connection test..."
              ssh -o ConnectTimeout=10 -o StrictHostKeyChecking=no -p ${{ secrets.EC2_PORT }} ${{ secrets.EC2_USER }}@${{ secrets.EC2_HOST }} "echo 'SSH connection successful'" || {
                echo "‚ùå SSH connection failed"
                exit 1
              }
            fi
          fi
          
          echo "‚úÖ Host added to known_hosts successfully"

      - name: Configure AWS credentials
        uses: aws-actions/configure-aws-credentials@v4
        with:
          aws-access-key-id: ${{ secrets.AWS_ACCESS_KEY_ID }}
          aws-secret-access-key: ${{ secrets.AWS_SECRET_ACCESS_KEY }}
          aws-region: us-east-1

      - name: Login to Amazon ECR
        id: login-ecr
        uses: aws-actions/amazon-ecr-login@v2

      - name: Deploy to EC2
        env:
          ECR_REGISTRY: ${{ steps.login-ecr.outputs.registry }}
          ECR_REPOSITORY: splitsafe-development
          IMAGE_TAG: ${{ github.sha }}
        run: |
          ssh -o StrictHostKeyChecking=no -p ${{ secrets.EC2_PORT }} ${{ secrets.EC2_USER }}@${{ secrets.EC2_HOST }} << 'EOF'
            set -e
            echo "üöÄ Starting deployment..."
            
            # Reload environment and ensure services are available
            echo "üîç Checking services availability..."
            source ~/.bashrc
            export PATH=$PATH:/usr/bin:/usr/local/bin
            
            # Ensure docker group membership is active
            newgrp docker 2>/dev/null || true
            
            # Create project directory if it doesn't exist
            echo "üìÅ Setting up project directory..."
            mkdir -p ${{ secrets.EC2_PROJECT_DIR }}
            cd ${{ secrets.EC2_PROJECT_DIR }}
            
            # Clone repository if it doesn't exist, otherwise pull latest changes
            if [ ! -d ".git" ]; then
              echo "üì• Cloning repository..."
              git clone https://github.com/${{ github.repository }}.git .
            else
              echo "üì• Pulling latest changes..."
              git pull origin ${{ github.ref_name }}
            fi
            
            # Load environment from SSM into .env for docker-compose
            echo "üîë Loading environment from SSM Parameter Store..."
            SSM_PATH="/splitsafe/development"
            AWS_REGION="us-east-1"
            aws ssm get-parameters-by-path --path "$SSM_PATH" --with-decryption --recursive --region "$AWS_REGION" --query 'Parameters[*].[Name,Value]' --output text | awk -F '\t' '{split($1,a,"/"); print a[length(a)] "=" $2}' > .env
            echo "‚úÖ .env created from SSM at $SSM_PATH (entries: $(wc -l < .env))"
            
            # Login to ECR
            echo "üîê Logging into ECR..."
            aws ecr get-login-password --region us-east-1 | docker login --username AWS --password-stdin ${{ steps.login-ecr.outputs.registry }}
            
            # Check if image exists in ECR before pulling
            echo "üîç Checking if image exists in ECR..."
            IMAGE_URI="${{ steps.login-ecr.outputs.registry }}/splitsafe-development:${{ github.sha }}"
            
            if ! aws ecr describe-images --repository-name splitsafe-development --image-ids imageTag=${{ github.sha }} --region us-east-1 2>/dev/null; then
              echo "‚ùå Image $IMAGE_URI does not exist in ECR!"
              echo "üîç Available images in repository:"
              aws ecr describe-images --repository-name splitsafe-development --region us-east-1 --query 'imageDetails[*].imageTags' --output table || echo "No images found"
              exit 1
            fi
            
            # Pre-pull image to surface any auth/network errors clearly
            echo "üê≥ Pulling image $IMAGE_URI..."
            docker pull "$IMAGE_URI"
            docker images | grep splitsafe-development || true
            
            # Stop existing containers
            echo "üõë Stopping existing containers..."
            docker compose -f docker/development/docker-compose.deploy.yml down || true
            docker rm -f frontend-development || true

            # Create a deploy-only compose file that uses the ECR image
            echo "üîß Creating deploy-only docker-compose file..."
            mkdir -p docker/development
            printf '%s\n' \
              "services:" \
              "  frontend:" \
              "    image: $IMAGE_URI" \
              "    container_name: frontend-development" \
              "    ports:" \
              "      - \"3000:3000\"" \
              "    env_file:" \
              "      - ../../.env" \
              "    restart: unless-stopped" \
              "    deploy:" \
              "      resources:" \
              "        limits:" \
              "          cpus: '1.0'" \
              "          memory: 1g" \
              "        reservations:" \
              "          cpus: '0.25'" \
              "          memory: 256m" \
              > docker/development/docker-compose.deploy.yml
            
            # Start all services with docker-compose
            echo "üöÄ Starting all services with docker-compose..."
            COMPOSE_COMPATIBILITY=1 docker compose -f docker/development/docker-compose.deploy.yml up -d

            # Setup Nginx reverse proxy for HTTPS
            echo "üîê Setting up Nginx reverse proxy..."
            DOMAIN="${{ secrets.DFX_DOMAIN || 'thesplitsafe.com' }}"
            
            # Install Nginx if not present
            if ! command -v nginx >/dev/null 2>&1; then
              echo "üì¶ Installing Nginx..."
              sudo apt-get update -qq
              sudo apt-get install -y nginx certbot python3-certbot-nginx
            fi
            
            # Create Nginx configuration
            echo "üåê Creating Nginx configuration for $DOMAIN..."
            sudo tee /etc/nginx/sites-available/splitsafe >/dev/null <<NGINX
            server {
                listen 80;
                server_name $DOMAIN;
                return 301 https://\$server_name\$request_uri;
            }
            
            server {
                listen 443 ssl http2;
                server_name $DOMAIN;
                
                # SSL configuration will be managed by Certbot
                ssl_certificate /etc/letsencrypt/live/$DOMAIN/fullchain.pem;
                ssl_certificate_key /etc/letsencrypt/live/$DOMAIN/privkey.pem;
                
                # Security headers
                add_header X-Frame-Options "SAMEORIGIN" always;
                add_header X-XSS-Protection "1; mode=block" always;
                add_header X-Content-Type-Options "nosniff" always;
                add_header Referrer-Policy "no-referrer-when-downgrade" always;
                add_header Content-Security-Policy "default-src 'self' http: https: data: blob: 'unsafe-inline'" always;
                
                # Proxy to Next.js app
                location / {
                    proxy_pass http://127.0.0.1:3000;
                    proxy_http_version 1.1;
                    proxy_set_header Upgrade \$http_upgrade;
                    proxy_set_header Connection 'upgrade';
                    proxy_set_header Host \$host;
                    proxy_set_header X-Real-IP \$remote_addr;
                    proxy_set_header X-Forwarded-For \$proxy_add_x_forwarded_for;
                    proxy_set_header X-Forwarded-Proto \$scheme;
                    proxy_cache_bypass \$http_upgrade;
                }
            }
            NGINX
            
            # Enable the site
            sudo ln -sf /etc/nginx/sites-available/splitsafe /etc/nginx/sites-enabled/
            sudo rm -f /etc/nginx/sites-enabled/default
            
            # Test Nginx configuration
            sudo nginx -t || { echo "‚ùå Invalid Nginx configuration"; exit 1; }
            
            # Setup SSL certificate with Let's Encrypt
            echo "üîí Setting up SSL certificate..."
            if [ ! -f "/etc/letsencrypt/live/$DOMAIN/fullchain.pem" ]; then
              echo "üìú Obtaining SSL certificate from Let's Encrypt..."
              sudo certbot --nginx -d $DOMAIN --non-interactive --agree-tos --email admin@$DOMAIN || {
                echo "‚ö†Ô∏è SSL certificate setup failed, continuing without HTTPS..."
                # Create a self-signed certificate for testing
                sudo mkdir -p /etc/ssl/private
                sudo openssl req -x509 -nodes -days 365 -newkey rsa:2048 \
                  -keyout /etc/ssl/private/nginx-selfsigned.key \
                  -out /etc/ssl/certs/nginx-selfsigned.crt \
                  -subj "/C=US/ST=State/L=City/O=Organization/CN=$DOMAIN"
                
                # Update Nginx config to use self-signed cert
                sudo sed -i 's|ssl_certificate /etc/letsencrypt/live/$DOMAIN/fullchain.pem;|ssl_certificate /etc/ssl/certs/nginx-selfsigned.crt;|g' /etc/nginx/sites-available/splitsafe
                sudo sed -i 's|ssl_certificate_key /etc/letsencrypt/live/$DOMAIN/privkey.pem;|ssl_certificate_key /etc/ssl/private/nginx-selfsigned.key;|g' /etc/nginx/sites-available/splitsafe
              }
            fi
            
            # Start/restart Nginx
            sudo systemctl enable nginx
            sudo systemctl restart nginx

            # Wait for services to be healthy
            echo "‚è≥ Waiting for services to be healthy..."
            sleep 30
            
            # Check service status
            echo "üîç Checking service status..."
            docker compose -f docker/development/docker-compose.deploy.yml ps
            echo "üîç Recent logs:"
            docker logs --tail 200 frontend-development || true

            # Quick health checks
            echo "üîé Probing endpoints..."
            curl -I http://localhost:3000 | sed -n '1,6p' || true
            curl -I https://$DOMAIN | sed -n '1,6p' || true
            
            echo "‚úÖ Deployment completed successfully!"
            echo "üåê Frontend should be accessible at:"
            echo "   - HTTP: http://$DOMAIN (redirects to HTTPS)"
            echo "   - HTTPS: https://$DOMAIN"
            echo "   - Direct: http://${{ secrets.EC2_HOST }}:3000"
            
          EOF
      - name: Notify deployment success
        if: success()
        run: |
          echo "‚úÖ Deployment to EC2 completed successfully!"
          echo "üåê Frontend URLs:"
          echo "   - HTTPS: https://${{ secrets.DFX_DOMAIN || 'thesplitsafe.com' }}"
          echo "   - HTTP: http://${{ secrets.DFX_DOMAIN || 'thesplitsafe.com' }} (redirects to HTTPS)"
          echo "   - Direct: http://${{ secrets.EC2_HOST }}:3000"
          echo "üê≥ Image: ${{ steps.login-ecr.outputs.registry }}/splitsafe-development:${{ github.sha }}"

      - name: Notify deployment failure
        if: failure()
        run: |
          echo "‚ùå Deployment to EC2 failed!"
          echo "Please check the logs for more details." 