name: CI/CD Build and Deploy to EC2

on:
  push:
    branches: [development]
  pull_request:
    branches: [development]
    types: [closed]
  workflow_dispatch: # Manual trigger

jobs:
  deploy-canister:
    runs-on: ubuntu-latest
    if: github.ref == 'refs/heads/development' || (github.event_name == 'pull_request' && github.event.pull_request.merged == true)
    outputs:
      canister_id: ${{ steps.deploy_dfx.outputs.canister_id }}
    steps:
      - name: Checkout code
        uses: actions/checkout@v4

      - name: Setup SSH agent (DFX EC2)
        uses: webfactory/ssh-agent@v0.8.0
        with:
          ssh-private-key: ${{ secrets.EC2_SSH_KEY }}

      - name: Add DFX EC2 to known hosts
        run: |
          echo "üîç Adding DFX host to known_hosts..."
          if ! ssh-keyscan -H -p ${{ secrets.EC2_PORT }} ${{ secrets.DFX_EC2_HOST }} >> ~/.ssh/known_hosts 2>/dev/null; then
            ssh-keyscan -H ${{ secrets.DFX_EC2_HOST }} >> ~/.ssh/known_hosts 2>/dev/null || true
          fi

      - name: Deploy canister on DFX EC2
        id: deploy_dfx
        run: |
          set -e
          DFX_HOST=${{ secrets.DFX_EC2_HOST }}
          DFX_PORT=${{ secrets.EC2_PORT }}
          DFX_USER=${{ secrets.EC2_USER }}
          PROJECT_DIR=${{ secrets.EC2_PROJECT_DIR }}

          # Ensure repo present and up to date on DFX host
          ssh -tt -o StrictHostKeyChecking=no -p "$DFX_PORT" "$DFX_USER@$DFX_HOST" "PROJECT_DIR='$PROJECT_DIR' ADMIN_PRINCIPAL='${{ secrets.ADMIN_PRINCIPAL }}' bash -s" <<'REMOTE'
            set -e
            mkdir -p "$PROJECT_DIR"
            cd "$PROJECT_DIR"
            if [ ! -d .git ]; then
              git clone https://github.com/${{ github.repository }}.git .
            else
              git fetch --all --tags
              git checkout ${{ github.ref_name }} || git checkout -B ${{ github.ref_name }}
              git pull origin ${{ github.ref_name }}
            fi

            # Ensure dfx is installed and on PATH
            if ! command -v dfx >/dev/null 2>&1; then
              echo "üì¶ Installing dfx..."
              export DFXVM_INIT_YES=1
              curl -fsSL https://internetcomputer.org/install.sh | bash
            fi
            # Load dfx env and PATH
            if [ -f "$HOME/.local/share/dfx/env" ]; then
              . "$HOME/.local/share/dfx/env"
            fi
            export PATH="$HOME/.local/share/dfx/bin:$HOME/.local/bin:$PATH"

            # Ensure replica is running (use existing dockerized replica if present)
            if curl -sSf http://127.0.0.1:4943/api/v2/status >/dev/null; then
              echo "‚úÖ Found running dfx replica on 127.0.0.1:4943; will use it"
            else
              echo "üöÄ Starting local dfx replica..."
              pkill -f 'dfx.*replica' >/dev/null 2>&1 || true
              dfx start --clean --host 127.0.0.1:4943 --background
              echo "‚è≥ Waiting for dfx replica to be ready..."
              for i in {1..30}; do
                if curl -sSf http://127.0.0.1:4943/api/v2/status >/dev/null; then
                  echo "‚úÖ dfx replica is up"
                  break
                fi
                sleep 2
              done
            fi

            # Deploy the canister (use repo root that contains dfx.json)
            cd "$PROJECT_DIR"
            export DFX_NETWORK=local
            export DFX_HOST=http://127.0.0.1:4943
            # Determine admin principal: prefer provided secret, else current identity
            if [ -z "$ADMIN_PRINCIPAL" ]; then
              ADMIN_PRINCIPAL=$(dfx identity get-principal)
            fi
            echo "Admin principal: $ADMIN_PRINCIPAL"
            dfx deploy split_dapp --argument "(principal \"$ADMIN_PRINCIPAL\", \"ml52i-qqaaa-aaaar-qaabq-cai\")" -y
          REMOTE

          # Read canister id from remote and expose as output
          CANISTER_ID=$(ssh -tt -o StrictHostKeyChecking=no -p "$DFX_PORT" "$DFX_USER@$DFX_HOST" "export PATH=\"$HOME/.local/share/dfx/bin:$HOME/.local/bin:\$PATH\"; cd '$PROJECT_DIR' && dfx canister id split_dapp" | tr -d '\r')
          echo "Canister ID: $CANISTER_ID"
          echo "canister_id=$CANISTER_ID" >> "$GITHUB_OUTPUT"

      - name: Configure AWS credentials (for SSM write)
        uses: aws-actions/configure-aws-credentials@v4
        with:
          aws-access-key-id: ${{ secrets.AWS_ACCESS_KEY_ID }}
          aws-secret-access-key: ${{ secrets.AWS_SECRET_ACCESS_KEY }}
          aws-region: us-east-1

      - name: Write canister ID to SSM
        run: |
          aws ssm put-parameter \
            --name "/splitsafe/development/NEXT_PUBLIC_CANISTER_ID_SPLIT_DAPP" \
            --type String \
            --value "${{ steps.deploy_dfx.outputs.canister_id }}" \
            --overwrite \
            --region us-east-1
  build:
    needs: deploy-canister
    runs-on: ubuntu-latest
    steps:
      - name: Checkout code
        uses: actions/checkout@v4

      - name: Setup Node.js
        uses: actions/setup-node@v4
        with:
          node-version: '20.17.0'
          cache: 'npm'
          cache-dependency-path: 'package-lock.json'

      - name: Install dependencies
        run: npm ci

      - name: Build application
        run: npm run build

  build-and-push-ecr:
    needs: build
    runs-on: ubuntu-latest
    if: github.ref == 'refs/heads/development' || (github.event_name == 'pull_request' && github.event.pull_request.merged == true)
    
    steps:
      - name: Checkout code
        uses: actions/checkout@v4

      - name: Configure AWS credentials
        uses: aws-actions/configure-aws-credentials@v4
        with:
          aws-access-key-id: ${{ secrets.AWS_ACCESS_KEY_ID }}
          aws-secret-access-key: ${{ secrets.AWS_SECRET_ACCESS_KEY }}
          aws-region: us-east-1

      - name: Login to Amazon ECR
        id: login-ecr
        uses: aws-actions/amazon-ecr-login@v2

      - name: Create ECR repository if it doesn't exist
        run: |
          REPO_NAME="splitsafe-development"
          echo "üîç Checking if ECR repository $REPO_NAME exists..."
          
          if ! aws ecr describe-repositories --repository-names $REPO_NAME --region us-east-1 2>/dev/null; then
            echo "üì¶ Creating ECR repository $REPO_NAME..."
            aws ecr create-repository \
              --repository-name $REPO_NAME \
              --region us-east-1 \
              --image-scanning-configuration scanOnPush=true \
              --image-tag-mutability MUTABLE
            echo "‚úÖ ECR repository $REPO_NAME created successfully"
          else
            echo "‚úÖ ECR repository $REPO_NAME already exists"
          fi

      - name: Build and push Docker image
        env:
          ECR_REGISTRY: ${{ steps.login-ecr.outputs.registry }}
          ECR_REPOSITORY: splitsafe-development
          IMAGE_TAG: ${{ github.sha }}
        run: |
          echo "üê≥ Building Docker image..."
          docker buildx create --use
          docker buildx build --platform linux/amd64 \
            -t $ECR_REGISTRY/$ECR_REPOSITORY:$IMAGE_TAG \
            -f docker/development/Dockerfile \
            --push .
          
          # Verify the image was pushed successfully
          echo "üîç Verifying image was pushed successfully..."
          if aws ecr describe-images --repository-name $ECR_REPOSITORY --image-ids imageTag=$IMAGE_TAG --region us-east-1 2>/dev/null; then
            echo "‚úÖ Image pushed and verified: $ECR_REGISTRY/$ECR_REPOSITORY:$IMAGE_TAG"
          else
            echo "‚ùå Failed to verify image in ECR: $ECR_REGISTRY/$ECR_REPOSITORY:$IMAGE_TAG"
            echo "üîç Available images in repository:"
            aws ecr describe-images --repository-name $ECR_REPOSITORY --region us-east-1 --query 'imageDetails[*].imageTags' --output table || echo "No images found"
            exit 1
          fi

  deploy:
    needs: [build, build-and-push-ecr]
    runs-on: ubuntu-latest
    if: github.ref == 'refs/heads/development' || (github.event_name == 'pull_request' && github.event.pull_request.merged == true)
    
    steps:
      - name: Checkout code
        uses: actions/checkout@v4

      - name: Setup SSH agent
        uses: webfactory/ssh-agent@v0.8.0
        with:
          ssh-private-key: ${{ secrets.EC2_SSH_KEY }}

      - name: Install network tools
        run: |
          sudo apt-get update
          sudo apt-get install -y netcat-openbsd

      - name: Add EC2 to known hosts
        run: |
          echo "üîç Testing connectivity to EC2 host..."
          echo "Host: ${{ secrets.EC2_HOST }}"
          echo "Port: ${{ secrets.EC2_PORT }}"
          
          # Test SSH port connectivity (skip ping as many EC2 instances block ICMP)
          if ! nc -z -w5 ${{ secrets.EC2_HOST }} ${{ secrets.EC2_PORT }}; then
            echo "‚ùå Cannot connect to ${{ secrets.EC2_HOST }}:${{ secrets.EC2_PORT }}"
            echo "üîç This could be due to:"
            echo "   - Incorrect EC2_HOST secret"
            echo "   - Incorrect EC2_PORT secret"
            echo "   - EC2 instance is down"
            echo "   - Security group blocking SSH"
            exit 1
          fi
          
          echo "‚úÖ SSH port is accessible, attempting SSH key scan..."
          
          # Try ssh-keyscan with different options
          if ! ssh-keyscan -H -p ${{ secrets.EC2_PORT }} ${{ secrets.EC2_HOST }} >> ~/.ssh/known_hosts 2>/dev/null; then
            echo "‚ö†Ô∏è ssh-keyscan failed, trying without port specification..."
            if ! ssh-keyscan -H ${{ secrets.EC2_HOST }} >> ~/.ssh/known_hosts 2>/dev/null; then
              echo "‚ùå Failed to add host to known_hosts"
              echo "üîç Attempting manual SSH connection test..."
              ssh -o ConnectTimeout=10 -o StrictHostKeyChecking=no -p ${{ secrets.EC2_PORT }} ${{ secrets.EC2_USER }}@${{ secrets.EC2_HOST }} "echo 'SSH connection successful'" || {
                echo "‚ùå SSH connection failed"
                exit 1
              }
            fi
          fi
          
          echo "‚úÖ Host added to known_hosts successfully"

      - name: Configure AWS credentials
        uses: aws-actions/configure-aws-credentials@v4
        with:
          aws-access-key-id: ${{ secrets.AWS_ACCESS_KEY_ID }}
          aws-secret-access-key: ${{ secrets.AWS_SECRET_ACCESS_KEY }}
          aws-region: us-east-1

      - name: Login to Amazon ECR
        id: login-ecr
        uses: aws-actions/amazon-ecr-login@v2

      - name: Deploy to EC2
        env:
          ECR_REGISTRY: ${{ steps.login-ecr.outputs.registry }}
          ECR_REPOSITORY: splitsafe-development
          IMAGE_TAG: ${{ github.sha }}
        run: |
          ssh -o StrictHostKeyChecking=no -p ${{ secrets.EC2_PORT }} ${{ secrets.EC2_USER }}@${{ secrets.EC2_HOST }} << 'EOF'
            set -e
            echo "üöÄ Starting deployment..."
            
            # Reload environment and ensure services are available
            echo "üîç Checking services availability..."
            source ~/.bashrc
            export PATH=$PATH:/usr/bin:/usr/local/bin
            
            # Ensure docker group membership is active
            newgrp docker 2>/dev/null || true
            
            # Create project directory if it doesn't exist
            echo "üìÅ Setting up project directory..."
            mkdir -p ${{ secrets.EC2_PROJECT_DIR }}
            cd ${{ secrets.EC2_PROJECT_DIR }}
            
            # Clone repository if it doesn't exist, otherwise pull latest changes
            if [ ! -d ".git" ]; then
              echo "üì• Cloning repository..."
              git clone https://github.com/${{ github.repository }}.git .
            else
              echo "üì• Pulling latest changes..."
              git pull origin ${{ github.ref_name }}
            fi
            
            # Load environment from SSM into .env for docker-compose
            echo "üîë Loading environment from SSM Parameter Store..."
            SSM_PATH="/splitsafe/development"
            AWS_REGION="us-east-1"
            aws ssm get-parameters-by-path --path "$SSM_PATH" --with-decryption --recursive --region "$AWS_REGION" --query 'Parameters[*].[Name,Value]' --output text | awk -F '\t' '{split($1,a,"/"); print a[length(a)] "=" $2}' > .env
            echo "‚úÖ .env created from SSM at $SSM_PATH (entries: $(wc -l < .env))"
            
            # Login to ECR
            echo "üîê Logging into ECR..."
            aws ecr get-login-password --region us-east-1 | docker login --username AWS --password-stdin ${{ steps.login-ecr.outputs.registry }}
            
            # Check if image exists in ECR before pulling
            echo "üîç Checking if image exists in ECR..."
            IMAGE_URI="${{ steps.login-ecr.outputs.registry }}/splitsafe-development:${{ github.sha }}"
            
            if ! aws ecr describe-images --repository-name splitsafe-development --image-ids imageTag=${{ github.sha }} --region us-east-1 2>/dev/null; then
              echo "‚ùå Image $IMAGE_URI does not exist in ECR!"
              echo "üîç Available images in repository:"
              aws ecr describe-images --repository-name splitsafe-development --region us-east-1 --query 'imageDetails[*].imageTags' --output table || echo "No images found"
              exit 1
            fi
            
            # Pre-pull image to surface any auth/network errors clearly
            echo "üê≥ Pulling image $IMAGE_URI..."
            docker pull "$IMAGE_URI"
            docker images | grep splitsafe-development || true
            
            # Stop existing containers
            echo "üõë Stopping existing containers..."
            docker compose -f docker/development/docker-compose.yml down || true
            docker stop splitsafe-development || true
            docker rm splitsafe-development || true
            
            # Update docker-compose.yml to use ECR image for frontend
            echo "üîß Updating docker-compose configuration..."
            sed -i "s|build:|image: $IMAGE_URI|g" docker/development/docker-compose.yml
            sed -i "/context:/d" docker/development/docker-compose.yml
            sed -i "/dockerfile:/d" docker/development/docker-compose.yml
            # Remove dev-only volume mounts to avoid masking node_modules inside the image
            sed -i "/^\s*volumes:\s*$/,/^\s*env_file:/{/^- \..*\/app/d;/^- \/app\/node_modules/d;/^\s*volumes:\s*$/d}" docker/development/docker-compose.yml || true
            
            # Start all services with docker-compose
            echo "üöÄ Starting all services with docker-compose..."
            docker compose -f docker/development/docker-compose.yml up -d
            
            # Wait for services to be healthy
            echo "‚è≥ Waiting for services to be healthy..."
            sleep 30
            
            # Check service status
            echo "üîç Checking service status..."
            docker compose -f docker/development/docker-compose.yml ps
            echo "üîç Recent logs:"
            docker logs --tail 200 frontend-development || true
            
            # DFX canisters are deployed in the separate 'deploy-canister' job on the DFX EC2
            
            echo "‚úÖ Deployment completed successfully!"
            echo "üåê Frontend should be accessible at http://${{ secrets.EC2_HOST }}:3000"
            echo "üîó DFX should be accessible at http://${{ secrets.EC2_HOST }}:4943"
            echo "üîó ICP canisters deployed and configured!"
          EOF





      - name: Notify deployment success
        if: success()
        run: |
          echo "‚úÖ Deployment to EC2 completed successfully!"
          echo "üåê Frontend URL: http://${{ secrets.EC2_HOST }}:3000"
          echo "üîó DFX URL: http://${{ secrets.EC2_HOST }}:4943"
          echo "üê≥ Image: ${{ steps.login-ecr.outputs.registry }}/splitsafe-development:${{ github.sha }}"

      - name: Notify deployment failure
        if: failure()
        run: |
          echo "‚ùå Deployment to EC2 failed!"
          echo "Please check the logs for more details." 