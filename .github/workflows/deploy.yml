name: CI/CD Build and Deploy to EC2

on:
  push:
    branches: [development]
  pull_request:
    branches: [development]
    types: [closed]
  workflow_dispatch: # Manual trigger

jobs:
  dfx-deploy:
    runs-on: ubuntu-latest
    steps:
      - name: Checkout code
        uses: actions/checkout@v4

      - name: Setup SSH agent
        uses: webfactory/ssh-agent@v0.8.0
        with:
          ssh-private-key: ${{ secrets.EC2_SSH_KEY }}

      - name: Add EC2 to known hosts
        run: |
          ssh-keyscan -H -p ${{ secrets.EC2_PORT }} ${{ secrets.EC2_HOST }} >> ~/.ssh/known_hosts 2>/dev/null

      - name: Deploy Motoko canisters to local dfx and update SSM
        run: |
          ssh -o StrictHostKeyChecking=no -p ${{ secrets.EC2_PORT }} ${{ secrets.EC2_USER }}@${{ secrets.EC2_HOST }} << 'EOF'
            set -e
            echo "üì¶ Preparing dfx workspace..."
            mkdir -p ~/apps/safesplit || true
            if [ ! -d "~/apps/safesplit/.git" ]; then
              echo "Cloning repo..."
              git clone https://github.com/${{ github.repository }}.git ~/apps/safesplit || true
            fi
            cd ~/apps/safesplit && git fetch --all && git checkout ${{ github.ref_name }} && git pull || true

            mkdir -p ~/dfxproj
            cp -f ~/apps/safesplit/dfx.json ~/dfxproj/
            rsync -av --delete ~/apps/safesplit/icp/src/ ~/dfxproj/src/

            echo "üöÄ Deploying canisters to local replica..."
            docker exec -i dfx bash -lc 'cd /app && dfx identity new --storage-mode plaintext deployer || true && dfx identity use deployer && dfx deploy --network local'

            LOCAL_ID=$(docker exec -i dfx bash -lc 'cd /app && dfx canister id split_dapp' | tr -d '\r')
            echo "Canister ID: $LOCAL_ID"

            echo "üîë Updating SSM parameters for frontend..."
            aws ssm put-parameter --name "/splitsafe/development/NEXT_PUBLIC_DFX_HOST" --type String --value "https://thesplitsafe.com" --overwrite --region us-east-1
            aws ssm put-parameter --name "/splitsafe/development/NEXT_PUBLIC_CANISTER_ID_SPLIT_DAPP" --type String --value "$LOCAL_ID" --overwrite --region us-east-1
          EOF

  build:
    needs: dfx-deploy
    runs-on: ubuntu-latest
    steps:
      - name: Checkout code
        uses: actions/checkout@v4

      - name: Read SSM public envs for build
        id: read-ssm
        run: |
          AWS_REGION=us-east-1
          SSM_PATH="/splitsafe/development"
          mapfile -t lines < <(aws ssm get-parameters-by-path --path "$SSM_PATH" --with-decryption --recursive --region "$AWS_REGION" --query 'Parameters[*].[Name,Value]' --output text)
          for l in "${lines[@]}"; do
            k=$(echo "$l" | awk '{print $1}')
            v=$(echo "$l" | awk '{print $2}')
            key=${k##*/}
            echo "$key=$v" >> $GITHUB_OUTPUT
          done

      - name: Setup Node.js
        uses: actions/setup-node@v4
        with:
          node-version: '20.17.0'
          cache: 'npm'
          cache-dependency-path: 'package-lock.json'

      - name: Install dependencies
        run: npm ci

      - name: Build application
        run: npm run build

  build-and-push-ecr:
    needs: build
    runs-on: ubuntu-latest
    if: github.ref == 'refs/heads/development' || (github.event_name == 'pull_request' && github.event.pull_request.merged == true)
    
    steps:
      - name: Checkout code
        uses: actions/checkout@v4

      - name: Configure AWS credentials
        uses: aws-actions/configure-aws-credentials@v4
        with:
          aws-access-key-id: ${{ secrets.AWS_ACCESS_KEY_ID }}
          aws-secret-access-key: ${{ secrets.AWS_SECRET_ACCESS_KEY }}
          aws-region: us-east-1

      - name: Login to Amazon ECR
        id: login-ecr
        uses: aws-actions/amazon-ecr-login@v2

      - name: Read SSM public envs for build
        id: read-ssm
        run: |
          AWS_REGION=us-east-1
          SSM_PATH="/splitsafe/development"
          mapfile -t lines < <(aws ssm get-parameters-by-path --path "$SSM_PATH" --with-decryption --recursive --region "$AWS_REGION" --query 'Parameters[*].[Name,Value]' --output text)
          for l in "${lines[@]}"; do
            k=$(echo "$l" | awk '{print $1}')
            v=$(echo "$l" | awk '{print $2}')
            key=${k##*/}
            echo "$key=$v" >> $GITHUB_OUTPUT
          done

      - name: Create ECR repository if it doesn't exist
        run: |
          REPO_NAME="splitsafe-development"
          echo "üîç Checking if ECR repository $REPO_NAME exists..."
          
          if ! aws ecr describe-repositories --repository-names $REPO_NAME --region us-east-1 2>/dev/null; then
            echo "üì¶ Creating ECR repository $REPO_NAME..."
            aws ecr create-repository \
              --repository-name $REPO_NAME \
              --region us-east-1 \
              --image-scanning-configuration scanOnPush=true \
              --image-tag-mutability MUTABLE
            echo "‚úÖ ECR repository $REPO_NAME created successfully"
          else
            echo "‚úÖ ECR repository $REPO_NAME already exists"
          fi

      - name: Build and push Docker image
        env:
          ECR_REGISTRY: ${{ steps.login-ecr.outputs.registry }}
          ECR_REPOSITORY: splitsafe-development
          IMAGE_TAG: ${{ github.sha }}
          # Pull public envs from SSM so Next.js client bundle gets them at build time
          NEXT_PUBLIC_DFX_HOST: ${{ steps.read-ssm.outputs.NEXT_PUBLIC_DFX_HOST }}
          NEXT_PUBLIC_CANISTER_ID_SPLIT_DAPP: ${{ steps.read-ssm.outputs.NEXT_PUBLIC_CANISTER_ID_SPLIT_DAPP }}
          NEXT_PUBLIC_DOMAIN: ${{ steps.read-ssm.outputs.NEXT_PUBLIC_DOMAIN }}
          NEXT_PUBLIC_DEVELOPMENT_DOMAIN: ${{ steps.read-ssm.outputs.NEXT_PUBLIC_DEVELOPMENT_DOMAIN }}
          NEXT_PUBLIC_BLOCKSTREAM_URL: ${{ steps.read-ssm.outputs.NEXT_PUBLIC_BLOCKSTREAM_URL }}
          NEXT_PUBLIC_MEMPOOL_URL: ${{ steps.read-ssm.outputs.NEXT_PUBLIC_MEMPOOL_URL }}
          NEXT_PUBLIC_ICP_DASHBOARD_URL: ${{ steps.read-ssm.outputs.NEXT_PUBLIC_ICP_DASHBOARD_URL }}
          NEXT_PUBLIC_ICSCAN_URL: ${{ steps.read-ssm.outputs.NEXT_PUBLIC_ICSCAN_URL }}
        run: |
          echo "üê≥ Building Production Docker image..."
          docker buildx create --use || true
          docker buildx build --platform linux/amd64 \
            -t $ECR_REGISTRY/$ECR_REPOSITORY:$IMAGE_TAG \
            -f docker/production/Dockerfile \
            --build-arg NEXT_PUBLIC_DFX_HOST="$NEXT_PUBLIC_DFX_HOST" \
            --build-arg NEXT_PUBLIC_CANISTER_ID_SPLIT_DAPP="$NEXT_PUBLIC_CANISTER_ID_SPLIT_DAPP" \
            --build-arg NEXT_PUBLIC_DOMAIN="$NEXT_PUBLIC_DOMAIN" \
            --build-arg NEXT_PUBLIC_DEVELOPMENT_DOMAIN="$NEXT_PUBLIC_DEVELOPMENT_DOMAIN" \
            --build-arg NEXT_PUBLIC_BLOCKSTREAM_URL="$NEXT_PUBLIC_BLOCKSTREAM_URL" \
            --build-arg NEXT_PUBLIC_MEMPOOL_URL="$NEXT_PUBLIC_MEMPOOL_URL" \
            --build-arg NEXT_PUBLIC_ICP_DASHBOARD_URL="$NEXT_PUBLIC_ICP_DASHBOARD_URL" \
            --build-arg NEXT_PUBLIC_ICSCAN_URL="$NEXT_PUBLIC_ICSCAN_URL" \
            --push .
          
          # Verify the image was pushed successfully
          echo "üîç Verifying image was pushed successfully..."
          if aws ecr describe-images --repository-name $ECR_REPOSITORY --image-ids imageTag=$IMAGE_TAG --region us-east-1 2>/dev/null; then
            echo "‚úÖ Image pushed and verified: $ECR_REGISTRY/$ECR_REPOSITORY:$IMAGE_TAG"
          else
            echo "‚ùå Failed to verify image in ECR: $ECR_REGISTRY/$ECR_REPOSITORY:$IMAGE_TAG"
            echo "üîç Available images in repository:"
            aws ecr describe-images --repository-name $ECR_REPOSITORY --region us-east-1 --query 'imageDetails[*].imageTags' --output table || echo "No images found"
            exit 1
          fi

  deploy:
    needs: [build, build-and-push-ecr]
    runs-on: ubuntu-latest
    if: github.ref == 'refs/heads/development' || (github.event_name == 'pull_request' && github.event.pull_request.merged == true)
    
    steps:
      - name: Checkout code
        uses: actions/checkout@v4

      - name: Setup SSH agent
        uses: webfactory/ssh-agent@v0.8.0
        with:
          ssh-private-key: ${{ secrets.EC2_SSH_KEY }}

      - name: Install network tools
        run: |
          sudo apt-get update
          sudo apt-get install -y netcat-openbsd

      - name: Add EC2 to known hosts
        run: |
          echo "üîç Testing connectivity to EC2 host..."
          echo "Host: ${{ secrets.EC2_HOST }}"
          echo "Port: ${{ secrets.EC2_PORT }}"
          
          # Test SSH port connectivity (skip ping as many EC2 instances block ICMP)
          if ! nc -z -w5 ${{ secrets.EC2_HOST }} ${{ secrets.EC2_PORT }}; then
            echo "‚ùå Cannot connect to ${{ secrets.EC2_HOST }}:${{ secrets.EC2_PORT }}"
            echo "üîç This could be due to:"
            echo "   - Incorrect EC2_HOST secret"
            echo "   - Incorrect EC2_PORT secret"
            echo "   - EC2 instance is down"
            echo "   - Security group blocking SSH"
            exit 1
          fi
          
          echo "‚úÖ SSH port is accessible, attempting SSH key scan..."
          
          # Try ssh-keyscan with different options
          if ! ssh-keyscan -H -p ${{ secrets.EC2_PORT }} ${{ secrets.EC2_HOST }} >> ~/.ssh/known_hosts 2>/dev/null; then
            echo "‚ö†Ô∏è ssh-keyscan failed, trying without port specification..."
            if ! ssh-keyscan -H ${{ secrets.EC2_HOST }} >> ~/.ssh/known_hosts 2>/dev/null; then
              echo "‚ùå Failed to add host to known_hosts"
              echo "üîç Attempting manual SSH connection test..."
              ssh -o ConnectTimeout=10 -o StrictHostKeyChecking=no -p ${{ secrets.EC2_PORT }} ${{ secrets.EC2_USER }}@${{ secrets.EC2_HOST }} "echo 'SSH connection successful'" || {
                echo "‚ùå SSH connection failed"
                exit 1
              }
            fi
          fi
          
          echo "‚úÖ Host added to known_hosts successfully"

      - name: Configure AWS credentials
        uses: aws-actions/configure-aws-credentials@v4
        with:
          aws-access-key-id: ${{ secrets.AWS_ACCESS_KEY_ID }}
          aws-secret-access-key: ${{ secrets.AWS_SECRET_ACCESS_KEY }}
          aws-region: us-east-1

      - name: Login to Amazon ECR
        id: login-ecr
        uses: aws-actions/amazon-ecr-login@v2

      - name: Deploy to EC2
        env:
          ECR_REGISTRY: ${{ steps.login-ecr.outputs.registry }}
          ECR_REPOSITORY: splitsafe-development
          IMAGE_TAG: ${{ github.sha }}
        run: |
          ssh -o StrictHostKeyChecking=no -p ${{ secrets.EC2_PORT }} ${{ secrets.EC2_USER }}@${{ secrets.EC2_HOST }} << 'EOF'
            set -e
            echo "üöÄ Starting deployment..."
            
            # Reload environment and ensure services are available
            echo "üîç Checking services availability..."
            source ~/.bashrc
            export PATH=$PATH:/usr/bin:/usr/local/bin
            
            # Ensure docker group membership is active
            newgrp docker 2>/dev/null || true
            
            # Create project directory if it doesn't exist
            echo "üìÅ Setting up project directory..."
            mkdir -p ${{ secrets.EC2_PROJECT_DIR }}
            cd ${{ secrets.EC2_PROJECT_DIR }}
            
            # Clone repository if it doesn't exist, otherwise pull latest changes
            if [ ! -d ".git" ]; then
              echo "üì• Cloning repository..."
              git clone https://github.com/${{ github.repository }}.git .
            else
              echo "üì• Pulling latest changes..."
              git pull origin ${{ github.ref_name }}
            fi
            
            # Load environment from SSM into .env for docker-compose
            echo "üîë Loading environment from SSM Parameter Store..."
            SSM_PATH="/splitsafe/development"
            AWS_REGION="us-east-1"
            aws ssm get-parameters-by-path --path "$SSM_PATH" --with-decryption --recursive --region "$AWS_REGION" --query 'Parameters[*].[Name,Value]' --output text | awk -F '\t' '{split($1,a,"/"); print a[length(a)] "=" $2}' > .env
            echo "‚úÖ .env created from SSM at $SSM_PATH (entries: $(wc -l < .env))"
            
            # Login to ECR
            echo "üîê Logging into ECR..."
            aws ecr get-login-password --region us-east-1 | docker login --username AWS --password-stdin ${{ steps.login-ecr.outputs.registry }}
            
            # Check if image exists in ECR before pulling
            echo "üîç Checking if image exists in ECR..."
            IMAGE_URI="${{ steps.login-ecr.outputs.registry }}/splitsafe-development:${{ github.sha }}"
            
            if ! aws ecr describe-images --repository-name splitsafe-development --image-ids imageTag=${{ github.sha }} --region us-east-1 2>/dev/null; then
              echo "‚ùå Image $IMAGE_URI does not exist in ECR!"
              echo "üîç Available images in repository:"
              aws ecr describe-images --repository-name splitsafe-development --region us-east-1 --query 'imageDetails[*].imageTags' --output table || echo "No images found"
              exit 1
            fi
            
            # Pre-pull image to surface any auth/network errors clearly
            echo "üê≥ Pulling image $IMAGE_URI..."
            docker pull "$IMAGE_URI"
            docker images | grep splitsafe-development || true
            
            # Stop existing containers
            echo "üõë Stopping existing containers..."
            docker compose -f docker/development/docker-compose.deploy.yml down || true
            docker rm -f frontend-development || true

            # Create a deploy-only compose file that uses the ECR image
            echo "üîß Creating deploy-only docker-compose file..."
            mkdir -p docker/development
            printf '%s\n' \
              "services:" \
              "  frontend:" \
              "    image: $IMAGE_URI" \
              "    container_name: frontend-development" \
              "    ports:" \
              "      - \"3000:3000\"" \
              "    env_file:" \
              "      - ../../.env" \
              "    restart: unless-stopped" \
              "    deploy:" \
              "      resources:" \
              "        limits:" \
              "          cpus: '1.0'" \
              "          memory: 1g" \
              "        reservations:" \
              "          cpus: '0.25'" \
              "          memory: 256m" \
              > docker/development/docker-compose.deploy.yml
            
            # Start all services with docker-compose
            echo "üöÄ Starting all services with docker-compose..."
            COMPOSE_COMPATIBILITY=1 docker compose -f docker/development/docker-compose.deploy.yml up -d
            
            # Ensure Caddy is installed and configured to proxy HTTPS
            echo "üîê Ensuring Caddy (TLS reverse proxy) is installed and configured..."
            DOMAIN="${{ secrets.DFX_DOMAIN || 'thesplitsafe.com' }}"
            APP_DOMAIN="app.$DOMAIN"
            if ! command -v caddy >/dev/null 2>&1; then
              echo "üì¶ Installing Caddy..."
              sudo apt-get update -qq
              sudo apt-get install -y debian-keyring debian-archive-keyring apt-transport-https curl gnupg lsb-release
              curl -1sLf 'https://dl.cloudsmith.io/public/caddy/stable/gpg.key' | sudo gpg --dearmor -o /usr/share/keyrings/caddy-stable-archive-keyring.gpg
              echo "deb [signed-by=/usr/share/keyrings/caddy-stable-archive-keyring.gpg] https://dl.cloudsmith.io/public/caddy/stable/deb/ubuntu $(lsb_release -cs) main" | sudo tee /etc/apt/sources.list.d/caddy-stable.list
              sudo apt-get update -qq
              sudo apt-get install -y caddy
            fi
            echo "üåê Writing Caddyfile for $DOMAIN and $APP_DOMAIN..."
            sudo mkdir -p /etc/caddy
            sudo tee /etc/caddy/Caddyfile >/dev/null <<CADDY
            ${DOMAIN} {
              encode zstd gzip
              reverse_proxy 127.0.0.1:4943
            }
            ${APP_DOMAIN} {
              encode zstd gzip
              reverse_proxy 127.0.0.1:3000
            }
            CADDY
            sudo caddy validate --config /etc/caddy/Caddyfile || { echo "‚ùå Invalid Caddyfile"; exit 1; }
            sudo systemctl enable --now caddy
            sudo systemctl reload caddy || true

            # Ensure local dfx replica is running and bound to loopback, as root (for volume perms)
            echo "üß™ Ensuring local dfx replica is running..."
            if ! docker ps --format '{{.Names}}' | grep -q '^dfx$'; then
              docker rm -f dfx 2>/dev/null || true
              docker volume create dfx_cache >/dev/null
              docker volume create dfx_config >/dev/null
              docker run -d --name dfx --restart unless-stopped --cpus 1 --memory 1g --memory-swap 2g --user 0 \
                -p 127.0.0.1:4943:4943 -e DFX_NETWORK=local \
                -v dfx_cache:/home/dfx/.cache -v dfx_config:/home/dfx/.config \
                fleek/dfx:latest dfx start --clean --host 0.0.0.0:4943
              echo "‚úÖ dfx container started"
            else
              echo "‚úÖ dfx container already running"
            fi

            # Wait for services to be healthy
            echo "‚è≥ Waiting for services to be healthy..."
            sleep 30
            
            # Check service status
            echo "üîç Checking service status..."
            docker compose -f docker/development/docker-compose.deploy.yml ps
            echo "üîç Recent logs:"
            docker logs --tail 200 frontend-development || true

            # Quick external checks
            echo "üîé Probing HTTPS endpoints via Caddy..."
            curl -I https://$DOMAIN | sed -n '1,6p' || true
            curl -I https://$APP_DOMAIN | sed -n '1,6p' || true
            
            echo "‚úÖ Deployment completed successfully!"
            echo "üåê Frontend should be accessible at http://${{ secrets.EC2_HOST }}:3000"
            echo "üåê DFX (via HTTPS reverse proxy) should be at https://${{ secrets.DFX_DOMAIN || 'thesplitsafe.com' }}"
            
          EOF
      - name: Notify deployment success
        if: success()
        run: |
          echo "‚úÖ Deployment to EC2 completed successfully!"
          echo "üåê Frontend URL: http://${{ secrets.EC2_HOST }}:3000"
          echo "üåê DFX URL: https://${{ secrets.DFX_DOMAIN || 'thesplitsafe.com' }}"
          echo "üê≥ Image: ${{ steps.login-ecr.outputs.registry }}/splitsafe-development:${{ github.sha }}"

      - name: Notify deployment failure
        if: failure()
        run: |
          echo "‚ùå Deployment to EC2 failed!"
          echo "Please check the logs for more details." 